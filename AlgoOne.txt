Instructor -: Tim Roughgarden

Institution -: Stanford 

Part Ia
=========================================================================================================================

Moore's Law -: 
	1. A prediction made in 1965 by Intel co­‐founder Gordon Moore that the density of transistors in integrated circuits 
	would continue to double every 1 to 2 years.   

Integer Multiplication:
	1. The number of basic operations in conventional algorithm for multiplying two numbers of size n is <= 4*n^2
	2. So we can say that the algorithm is quadratic in input size.

Karatsuba Multiplication -: 
	1. Break inputs x and y each as x = 10^(n/2) * a + b and y = x = 10^(n/2) * c + d
	2. x.y = 10^n * ac + 10^(n/2) (ad + bc) + bd
	3. Recursively compute ac , bd and (a + b) (c + d). This way we will need only three recursive multiplications for 
	each step. 
	4. Overall use recursion method to compute product of two n-digit numbers	

Selection Sort -: 
	1. First it finds the smallest element in the array.
    2. Exchange that smallest element with the element at the first position.
    3. Then find the second smallest element and exchange that element with the element at the second position.
    4. This process continues until the complete array is sorted.

Insertion sort:
	1. For the ith iteration, the element at the ith position is compared with the element on its left
	2. If its smaller, it is swaped with that element
	3. The process repeats while the element is not smaller than the element on the left

Bubble sort -: 
	1. In ith iteration, ith element is compared with element on the right and the items are swapped till the item
	on the right is greater than the item on the left. 

Merge sort -:
	1. A classical example of divide and conquer algorithm design paradigm
	2. Improvement over selection, insertion and bubble sort, all of which are quadratic in complexity
	3. Recursively sort two half lists of the input arrays and then merge them together

Guiding Principles-:
	1. Worst case analysis -: Gurantees a minimum level of performance that holds for all inputs of the given size. The bound
	holds for all possible inputs of length n
	2. Ignore constant factors -: Be concerned about rates of growth rather than lower order terms and constant factors. As constants
	depends on architecture, compiler etc. We lose very little in terms of predictive power.
	3. Asymptotic analysis -: Focus on running time of large inputs 

Part Ib
=========================================================================================================================

Why asymptotic analysis -:
	1. Coarse enough to supress architecture, programming language and system-dependent details.
	2. Sharp enough to make useful comparisons between different algorithms, for large input sizes. 
	3. Lower order terms become increasingly irrelevant as the input size increases.
	4. Constant factors are highly dependent on system.

Big O notation -: 
	1. A function T(n) is defined for all positive integers
	2. T(n) = O(f(n)) iff there exists positive constants C and n_0 such that T(n) <= C * f(n) for all n >= n_0

Big Omega notation -: 
	1. T(n) = Omega(f(n)) iff there exists positive constants C and n_0 such that T(n) >= C * f(n) for all n >= n_0. So it 
	stands for lower bound, unlike the Big O which stands for the upper bound. 

Theta notation -: 
	1. It is for equals
	2. A functon T(n) = Theta(f(n)) iff T(n) = O(f(n)) and T(n) = Omega(f(n))
	3. This can be proved if we can find two constants C_0 and C_1 such that -: C_o * f(n) <= T(n) <= C_1 * f(n) 
	

Little o notation -: 
	1. T(n) = o(f(n)) iff for all constants C > 0; T(n) <= C * f(n) for all n >= n_0  

Part Ic
================================================================================================================================

Inversion -: 
	1. Measures how far (or close) the array is from being sorted. If array is already sorted then inversion count is 0. If array is 
	sorted in reverse order that inversion count is the maximum.
	2. Divide and conquer method of counting inversions in a list uses merge sort method. The input list is divided into halves
	and inversions are counted for them recursively. Then split inversions is counted between the two halves of the list. 
	By adding them up, total inversions are counted.  
